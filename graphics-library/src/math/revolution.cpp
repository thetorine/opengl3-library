#include <algorithm>
#include <cmath>
#include <glm/glm.hpp>

#include "math/constants.hpp"
#include "math/revolution.hpp"

namespace gl::math {
    // Wraps negative numbers around to d
    int wrap(int n, int d) {
        if (n >= 0) return n;
        return d + n;
    }

    // The vertices in the vector are stored in the format (x1, y1, z1, x2, y2, z2, ..., xn, yn, zn)
    // This function will retrieve the xyz coordinates at the specified index and return as a vec3.
    glm::vec3 getVertex(const std::vector<float> &vertices, int vertex) {
        int index { vertex * 3 };
        return glm::vec3(vertices[index], vertices[index + 1], vertices[index + 2]);
    }

    /*
        If the curve (fx(t), fy(t)) where t is in the range [bounds.first, bounds.second] is rotated,
        about the y axis, the result will be a 3D curve.
                   y
                   ^    z
                   |   /
                   |*****
                   | /  *
                   |/   *
        <----------|----------->x
                  /|    *
                 / |    *
                /  |*****
               /   |
                   v
        Rotating the curve specified by the asterisks(*) on the x and y axis around the y axis will form
        a cylinder.
    */
    std::vector<float> generateVertices(const std::function<float(float t)> &fx,
                                        const std::function<float(float t)> &fy,
                                        const std::pair<float, float> &bounds,
                                        bool rotate) {
        std::vector<float> vertices;

        // Use integers to avoid floating point errors.
        // This ensures that a constant number of points are generated per ring.
        // Hence it is easier to generate indices later on.

        // The number of points to generate on each instance of the rings created by rotating.
        int curveSamples { 100 };
        // The number of rings to generate.
        // The total number of points generated are curveSamples * ringSamples.
        // TODO: If the curve starts and finishes at the y axis - then there are a lot of points
        // close to each other at those points. 
        int ringSamples { rotate ? 100 : 1 };

        // The angle between each ring.
        float thetaSample { gl::math::PI * 2.0f / ringSamples };
        // The distance between each point on the curve. 
        float tSample { (bounds.second - bounds.first) / curveSamples };

        // Take a 2d curve in the first and fourth quadrant and rotate it around the y axis
        // to generate a 3d curve.
        for (int i { 0 }; i <= ringSamples; i++) {
            // Current rotation around the y axis. 
            float theta { i * thetaSample };
            float tx { std::cos(theta) };
            float tz { std::sin(theta) };

            for (int j { 0 }; j <= curveSamples; j++) {
                // Current point to calculate on the curve. 
                // The curve is rotated by the tx/tz values above. 
                float t { bounds.first + j * tSample };
                float x { fx(t) * tx };
                float y { fy(t) }; // Rotating about the y axis - it does not change. 
                float z { fx(t) * tz };
                vertices.insert(std::end(vertices), { x, y, z });
            }
        }

        return vertices;
    }

    std::vector<float> generateNormals(const std::function<float(float t)> &fx,
                                       const std::function<float(float t)> &fy,
                                       const std::pair<float, float> &bounds) {
        std::vector<float> normals;

        int curveSamples { 100 };
        int ringSamples { 100 };

        float thetaSample { gl::math::PI * 2.0f / ringSamples };
        float tSample { (bounds.second - bounds.first) / curveSamples };

        /*
            Basic idea: For every point on the mesh, calculate:
                - The point generated by moving in the direction of the curve.
                - The point generated by moving in the direction of the rotation.

            Then calculate the difference between the generated points which yields
            two tangent values at that point on the mesh.

            Then calculate the cross product of the tangents to calculate the normal
            at that point.

            Works at locations on the mesh where the points are not squashed together.
            Does not work so well at the top and bottom of the mesh.
        */

        for (int i { 0 }; i <= ringSamples; i++) {
            float theta { i * thetaSample };
            float tx { std::cos(theta) };
            float tz { std::sin(theta) };

            for (int j { 0 }; j <= curveSamples; j++) {
                // Calculate the point on the mesh
                float t { bounds.first + j * tSample };
                float x1 { fx(t) * tx };
                float y1 { fy(t) };
                float z1 { fx(t) * tz };

                // How much to change either t or theta to yield the tangent.
                // The smaller the change value - the more the generated mesh
                // looks like a golf ball :)
                float change { 0.001f };

                // Calculate the point generated by moving in the direction of the curve.
                float x2 { fx(t - change) * tx };
                float y2 { fy(t - change) };
                float z2 { fx(t - change) * tz };

                // Calculate the tangent at this point.
                float dx1 { x1 - x2 };
                float dy1 { y1 - y2 };
                float dz1 { z1 - z2 };

                // Calculate the point generated by moving in the direction of the rotation.
                float tx1 { std::cos(theta - change) };
                float tz1 { std::sin(theta - change) };

                float x3 { fx(t) * tx1 };
                float y3 { fy(t) };
                float z3 { fx(t) * tz1 };

                // Calculate the tangent at this point.
                float dx2 { x1 - x3 };
                float dy2 { y1 - y3 };
                float dz2 { z1 - z3 };

                // Cross the two tangents to yield the normal at this point. 
                glm::vec3 v1(dx1, dy1, dz1);
                glm::vec3 v2(dx2, dy2, dz2);
                glm::vec3 n { glm::normalize(glm::cross(v2, v1)) };

                normals.insert(std::end(normals), { n.x, n.y, n.z });
            }
        }

        return normals;
    }

    std::vector<int> generateIndices(const std::vector<float> &vertices,
                                     const std::pair<float, float> &bounds) {
        std::vector<int> indices;

        // Basic algorithm: Create triangles between the current and previous ring.
        // Since there are a constant number of points on each ring, we can subtract that constant number
        // from the current vertex to retrieve the index of the adjacent vertex. 
        // Then the indexes need to be wrapped to avoid negative indices. 

        // The number of points on each ring if a curve in quadrants 1 and 4 is swept around the y axis. 
        int curveSamples { 101 };
        // Every three elements forms one vertex (x, y, z) and indices map to each vertex. 
        int vertexCount = static_cast<int>(vertices.size() / static_cast<size_t>(3));
        for (int i { 0 }; i < vertexCount; i++) {

            // Creates the following face:
            /*
                o-o
                |/
                o o
            */
            indices.insert(std::end(indices),
                           { wrap(i - curveSamples + 1, vertexCount), wrap(i - curveSamples, vertexCount), i });

            // Creates the following face:
            /*
                o-o
                 /|
                o-o
            */
            indices.insert(std::end(indices),
                           { wrap(i - curveSamples, vertexCount), wrap(i - 1, vertexCount), i });
        }

        return indices;
    }

    std::vector<float> generateNormals_broken(const std::vector<float> &vertices,
                                              const std::vector<int> &indices) {
        // Vertex normals can be calculated by taking the 
        // average of all adjacent face normals. 

        // This vector will sum all the face normals that are adjacent to each vertex. 
        std::vector<glm::vec3> normalSum(vertices.size() / 3);
        // This vector will count the number of face normals that are adjacent to each vertex.
        std::vector<int> faceNormalCount(vertices.size() / 3);

        for (int i { 0 }; i <= indices.size() - 3; i += 3) {
            // Retrieve the indexes to each of the three vertices that make up each face. 
            int v1Index { indices[i] };
            int v2Index { indices[i + 1] };
            int v3Index { indices[i + 2] };

            // Get the vertex xyz coordinates at each vertex index.
            glm::vec3 v1 { getVertex(vertices, v1Index) };
            glm::vec3 v2 { getVertex(vertices, v2Index) };
            glm::vec3 v3 { getVertex(vertices, v3Index) };

            // The face normal is calculated by calculating the cross product
            // of P(i-1) - P(i) and P(i+1) - P(i).
            glm::vec3 i1 { v1 - v2 }; // P(i-1) - P(i)
            glm::vec3 i2 { v3 - v2 }; // P(i+1) - P(i)

            // [P(i-1) - P(i)] X [P(i+1) - P(i)]
            glm::vec3 faceNormal { glm::normalize(glm::cross(i1, i2)) };

            // Add the face normal to the normalSum for each vertex of the face.
            normalSum[v1Index] += faceNormal;
            normalSum[v2Index] += faceNormal;
            normalSum[v3Index] += faceNormal;

            // Increment the counts.
            faceNormalCount[v1Index] += 1;
            faceNormalCount[v2Index] += 1;
            faceNormalCount[v3Index] += 1;
        }

        std::vector<float> result;
        for (int i { 0 }; i < normalSum.size(); i++) {
            // Calculate the vertex normal by calculating the average of the face normals. 
            glm::vec3 normal { normalSum[i] / static_cast<float>(faceNormalCount[i]) };
            result.insert(std::end(result), { normal.x, normal.y, normal.z });
        }

        return result;
    }
}